# Caching Implementation Documentation

## Overview
The caching system in the BRMH service is implemented to optimize performance and reduce the load on DynamoDB by storing frequently accessed data in memory. This document outlines the caching mechanism, its configuration, and usage.

## Cache Configuration

### Cache Storage
```javascript
const scanCache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes in milliseconds
```

- **Storage Type**: In-memory Map
- **TTL (Time To Live)**: 5 minutes
- **Scope**: Application-level (cleared on server restart)

### Cache Key Generation
```javascript
function generateCacheKey(tableName, params) {
  return `${tableName}:${JSON.stringify(params)}`;
}
```

The cache key is generated by combining:
- Table name
- Query parameters (stringified)
- This ensures unique keys for different query combinations

## Cache Implementation Details

### 1. Cache Structure
- Uses JavaScript's native `Map` data structure
- Key: Generated cache key string
- Value: Object containing:
  - `data`: The cached response
  - `timestamp`: When the cache entry was created

### 2. Cache Operations

#### Reading from Cache
```javascript
const cacheKey = generateCacheKey(tableName, params);
const cachedData = scanCache.get(cacheKey);

if (cachedData && (Date.now() - cachedData.timestamp) < CACHE_TTL) {
  return cachedData.data;
}
```

#### Writing to Cache
```javascript
scanCache.set(cacheKey, {
  data: response,
  timestamp: Date.now()
});
```

### 3. Cache Invalidation
- Automatic: Entries expire after TTL (5 minutes)
- Manual: Cache is cleared when:
  - New items are created
  - Items are updated
  - Items are deleted

## DynamoDB Data Formatting

### Formatting Functions
The caching system works in conjunction with DynamoDB formatting functions that ensure proper data structure when interacting with DynamoDB:

```javascript
// Helper function to format objects for DynamoDB
function formatDynamoDBMap(obj) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (value === null || value === undefined) {
      result[key] = { NULL: true };
    } else if (typeof value === 'string') {
      result[key] = { S: value };
    } else if (typeof value === 'number') {
      result[key] = { N: value.toString() };
    } else if (typeof value === 'boolean') {
      result[key] = { BOOL: value };
    } else if (Array.isArray(value)) {
      result[key] = { L: value.map(item => formatDynamoDBValue(item)) };
    } else if (typeof value === 'object') {
      result[key] = { M: formatDynamoDBMap(value) };
    }
  }
  return result;
}

function formatDynamoDBValue(value) {
  if (value === null || value === undefined) {
    return { NULL: true };
  } else if (typeof value === 'string') {
    return { S: value };
  } else if (typeof value === 'number') {
    return { N: value.toString() };
  } else if (typeof value === 'boolean') {
    return { BOOL: value };
  } else if (Array.isArray(value)) {
    return { L: value.map(item => formatDynamoDBValue(item)) };
  } else if (typeof value === 'object') {
    return { M: formatDynamoDBMap(value) };
  }
  return { NULL: true };
}
```

### Data Type Handling
These functions handle the following data types:
- **Strings**: Converted to `{ S: value }`
- **Numbers**: Converted to `{ N: value.toString() }`
- **Booleans**: Converted to `{ BOOL: value }`
- **Arrays**: Converted to `{ L: [formatted values] }`
- **Objects**: Converted to `{ M: formatted object }`
- **Null/Undefined**: Converted to `{ NULL: true }`

### Integration with Caching
When caching DynamoDB responses:
1. Data is stored in the cache in its original format
2. When retrieving from cache, no additional formatting is needed
3. When writing to DynamoDB, the formatting functions ensure proper data structure

## Usage Guidelines

### When to Use Cache
1. **Read-Heavy Operations**: Ideal for frequently accessed, rarely changed data
2. **Expensive Queries**: Complex scans or queries that are resource-intensive
3. **Consistent Data**: Data that doesn't change frequently

### When Not to Use Cache
1. **Write-Heavy Operations**: Data that changes frequently
2. **Real-time Data**: When data freshness is critical
3. **Sensitive Data**: When data security is paramount

## Performance Considerations

### Memory Usage
- Cache size is limited by available system memory
- Each cached item includes:
  - Response data
  - Timestamp
  - Metadata

### Cache Hit Ratio
- Monitor cache hit ratio to optimize TTL
- Adjust TTL based on data update frequency
- Consider implementing cache size limits

## Best Practices

1. **Cache Key Design**
   - Keep keys concise but unique
   - Include all relevant query parameters
   - Avoid storing sensitive data in keys

2. **TTL Management**
   - Set TTL based on data update frequency
   - Consider implementing variable TTLs
   - Monitor cache effectiveness

3. **Error Handling**
   - Implement fallback mechanisms
   - Handle cache misses gracefully
   - Log cache-related errors

4. **Monitoring**
   - Track cache hit/miss rates
   - Monitor memory usage
   - Log cache operations

## Example Usage

```javascript
// Reading with cache
async function getCachedItems(tableName, params) {
  const cacheKey = generateCacheKey(tableName, params);
  const cachedData = scanCache.get(cacheKey);

  if (cachedData && (Date.now() - cachedData.timestamp) < CACHE_TTL) {
    return cachedData.data;
  }

  // If not in cache or expired, fetch from DynamoDB
  const response = await fetchFromDynamoDB(tableName, params);
  
  // Update cache
  scanCache.set(cacheKey, {
    data: response,
    timestamp: Date.now()
  });

  return response;
}

// Writing to DynamoDB with proper formatting
async function createItemWithFormatting(tableName, item) {
  // Format the item for DynamoDB
  const formattedItem = formatDynamoDBMap(item);
  
  // Create the item in DynamoDB
  const command = new PutCommand({
    TableName: tableName,
    Item: formattedItem
  });
  
  await docClient.send(command);
  
  // Invalidate cache for this table
  invalidateTableCache(tableName);
  
  return {
    message: 'Item created successfully',
    item: item
  };
}
```

## Limitations

1. **Memory Constraints**
   - Cache size limited by available memory
   - No persistent storage
   - Cleared on server restart

2. **Scalability**
   - Single-server cache
   - No distributed caching
   - No cache synchronization

3. **Data Consistency**
   - Potential for stale data
   - TTL-based invalidation only
   - No real-time updates

## Future Improvements

1. **Distributed Caching**
   - Implement Redis or similar
   - Enable multi-server caching
   - Improve scalability

2. **Advanced Features**
   - Cache size limits
   - LRU eviction
   - Cache warming
   - Cache statistics

3. **Monitoring**
   - Cache hit/miss metrics
   - Memory usage tracking
   - Performance analytics 